<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>开发日志 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</title><link>/nebula-website/cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</link><description>Recent content in 开发日志 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 29 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="/nebula-website/cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml"/><item><title>D3.js 力导向图的显示优化</title><link>/nebula-website/cn/posts/d3-force-layout-optimization/</link><pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/d3-force-layout-optimization/</guid><description>D3.js 作为一个前端，说到可视化除了听过 D3.js 的大名，常见的可视化库还有 ECharts、Chart.js，这两个库功能也很强大，但是有一个共同特点是封装层次高，留给开发者可设计和控制的部分太少。和 EChart、Chart.js 等相比，D3.js** **的相对来说自由度会高很多，得益于 D3.js** **中的 **SVG 画图对事件处理器的支持**，D3.js 可将任意数据绑定到文档对象模型（DOM）上，也可以直接操作对象模型（DOM）完成 W3C DOM API 相关操作，对于想要展示自己设计图形的开发者，D3.js 绝对是一个不错的选择。
d3-force 力导向图 以实现一个关系网来说，d3-force 力导向图是不二的选择。d3-force 是 D3.js 实现以模拟粒子物理运动的 velocity Verlet 数值积分器的模块，可用来控制粒子和边秩序。在力导向图中，d3-force 中的每个节点都可以看成是一个放电粒子，粒子间存在某种斥力（库仑斥力）。同时，这些粒子间被它们之间的“边”所牵连，从而产生牵引力。
而 d3-force 中的粒子在斥力和牵引力的作用下，从随机无序的初态不断发生位移，逐渐趋于平衡有序。整个图只有点 / 边，图形实现样例较少且自定义样式居多。
下图就是最简单的关系网图，想要实现自己想要的关系网图，还是动手自己实现一个 D3.js 力导向图最佳。
构建 D3.js 力导向图 在这里实践过程中，我们用 D3.js 力导向图来对图数据库的数据关系进行分析，其节点和关系线直观地体现出图数据库的数据关系，并且还可以关联相对应的图数据库语句完成拓展查询。进阶来说，可通过对文档对象模型（DOM）的直接操作同步到数据库进而更新数据，当然操作这个比较复杂，😂 不在本文中详细讲述。
下面，我们来实现一个简单的力导向图，初窥 D3.js 对数据分析的作用和显示优化的一些思路。首先我们创建一个力导向图：
this.force = d3 .forceSimulation() // 为节点分配坐标 .nodes(data.vertexes) // 连接线 .force('link', linkForce) // 整个实例中心 .force('center', d3.forceCenter(width / 2, height / 2)) // 引力 .force('charge', d3.</description></item><item><title>图数据库 Nebula Graph 的代码变更测试覆盖率实践</title><link>/nebula-website/cn/posts/integrate-codecov-test-coverage-with-nebula-graph/</link><pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/integrate-codecov-test-coverage-with-nebula-graph/</guid><description>对于一个持续开发的大型工程而言，足够的测试是保证软件行为符合预期的有效手段，而不是仅仅依靠 code review 或者开发者自己的技术素质。测试的编写理想情况下应该完全定义软件的行为，但是通常情况都是很难达到这样理想的程度。而测试覆盖率就是检验测试覆盖软件行为的情况，通过检查测试覆盖情况可以帮助开发人员发现没有被覆盖到的代码。
测试覆盖信息搜集 Nebula Graph 主要是由 C++ 语言开发的，支持大部分 Linux 环境以及 gcc/clang 编译器，所以通过工具链提供的支持，我们可以非常方便地统计Nebula Graph的测试覆盖率。
gcc/clang 都支持 gcov 式的测试覆盖率功能，使用起来也是非常简单的，主要有如下几个步骤：
添加编译选项 --coverage -O0 -g  添加链接选项 --coverage  运行测试 使用 lcov，整合报告，例如 lcov --capture --directory . --output-file coverage.info  去掉外部代码统计，例如 lcov --remove coverage.info '*/opt/vesoft/*' -o clean.info  到这里测试覆盖信息已经搜集完毕，接下可以通过 genhtml 这样的工具生成 html，然后通过浏览器查看测试覆盖率，如下图所示：
但是这样是非常不方便的，因为在持续的开发过程，如果每次都要手动进行这样一套操作，那必然带来极大的人力浪费，所以现在的常用做法是将测试覆盖率写入 CI 并且和第三方平台（比如 Codecov，Coveralls）集成，这样开发人员完全不必关心测试覆盖信息的收集整理和展示问题，只需要发布代码后直接到第三方平台上查看覆盖情况即可，而且现在的第三方平台也支持直接在 PR 上评论覆盖情况使得查看覆盖率的变更情况更加方便。
集成 CI Github Action 现在主流的 CI 平台非常多，比如 Travis，azure-pipelines 以及 GitHub Action 等。Nebula Graph 选用的是 GitHub Action，对于 Action 我们在之前的《使用 Github Action 进行前端自动化发布》这篇文章里已经做过介绍。</description></item><item><title>基于 Jepsen 来发现几个 Raft 实现中的一致性问题(2)</title><link>/nebula-website/cn/posts/detect-data-consistency-issues-in-raft-implementing-with-jepsen/</link><pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/detect-data-consistency-issues-in-raft-implementing-with-jepsen/</guid><description>Nebula Graph 是一个高性能、高可用、强一致的分布式图数据库。由于 Nebula Graph 采用的是存储计算分离架构，在存储层实际只是暴露了简单的 kv 接口，采用 RocksDB 作为状态机，通过 Raft 一致性协议来保证多副本数据一致的问题。Raft 协议虽然比 Paxos 更加容易理解，但在工程实现上还是有很多需要注意和优化的地方。
另外，如何测试基于 Raft 的分布式系统也是困扰业界的问题，目前 Nebula 主要采用了 Jepsen 作为一致性验证工具。之前我的小伙伴已经在《Jepsen 测试框架在图数据库 Nebula Graph 中的实践》中做了详细的介绍，对 Jepsen 不太了解的同学可以先移步这篇文章。
在这篇文章中将着重介绍如何通过 Jepsen 来对 Nebula Graph 的分布式 kv 进行一致性验证。
强一致的定义 首先，我们需要什么了解叫强一致，它实际就是 Linearizability，也被称为线性一致性。引用《Designing Data-Intensive Applications》里一书里的定义：
In a linearizable system, as soon as one client successfully completes a write, all clients reading from the database must be able to see the value just written.</description></item><item><title>使用 Github Action 进行前端自动化发布</title><link>/nebula-website/cn/posts/github-action-automating-project-process/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/github-action-automating-project-process/</guid><description>前言 说起自动化，无论是在公司还是我们个人的项目中，都会用到或者编写一些工具来帮助我们去处理琐碎重复的工作，以节约时间提升效率，尤其是我们做前端开发会涉及诸如构建、部署、单元测试等这些开发工作流中重复的事项，本篇文章就是介绍如何利用 GitHub 提供的 Actions 来完成我们前端的发布自动化。
Github Actions 什么是 Actions 笔者个人理解为在某种条件下可被触发的任务，利用一个个任务（Action）就可组建成我们的工作流，想要更详细的介绍定义的同学可以移步 官方Action定义，有助获取更多的信息，这里就不搬运啦~
使用 Actions 的好处 前端自动化部署方案有多种，那么 GitHub 推出的 Actions 有什么魅力呢？在笔者看来，Action 在前端自动化发布有下面 3 点亮点：
免费，Action 可与 GitHub 中的 Repo 进行绑定（下图所示，具体操作见下文），开箱即用：这就意味着我们不需要提供跑任务的机器，也不用管怎么把任务流对接起来，只要简单地熟悉规则，就能将项目 run 起来。而我们大部分觉得某个工具麻烦，是因为使用步骤繁琐，若要实现功能 A，还需做 B/C/D 操作才行，这时候我们要么放弃要么转向操作更简单的工具，毕竟省时省事才是开发第一要务~ 任务插件化，持续丰富的插件开源市场：得益于 Github 定义了 Actions 规范，让我们使用的 Actions 时都是按某种已知规则开发，这使得 Actions 更易于装配复用，很多优秀的开发者在制作完成工作流后，将自己开发的 Actions 放到 GitHub 的 Actions 集市上去，这样尚未完成自己常规工作流的开发，不需要额外开发这些已有重复逻辑直接使用现成的他人 Actions 即可。在笔者的实践过程中，前端的构建部署工作流，就是用的各类现有的 Actions 组合实现的。 和 GitHub 集成好，可避免因为使用 Travis 等第三方工具引起额外的心智负担，在 GitHub 上可直接查看 CI/CD 的情况。 当然 Actions 还有许多其他好处，还待各位亲自尝试，至少使用过 Actions 的人都说好 😬</description></item><item><title>Dev 日志 | 一次 Segmentation Fault 和 GCC Illegal Instruction 编译问题排查</title><link>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</link><pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</guid><description>摘要 笔者最近在重新整理和编译 Nebula Graph 的第三方依赖，选出两个比较有意思的问题给大家分享一下。
Flex Segmentation Fault——Segmentation fault (core dumped) 在编译 Flex 过程中，遇到了 Segmentation fault：
make[2]: Entering directory &amp;#39;/home/dutor/flex-2.6.4/src&amp;#39; ./stage1flex -o stage1scan.c ./scan.l make[2]: *** [Makefile:1696: stage1scan.c] Segmentation fault (core dumped) 使用 gdb 查看 coredump：
Core was generated by `./stage1flex -o stage1scan.c ./scan.l'. Program terminated with signal SIGSEGV, Segmentation fault. #0 flexinit (argc=4, argv=0x7ffd25bea718) at main.c:976 976 action_array[0] = '\0'; (gdb) disas Dump of assembler code for function flexinit: 0x0000556c1b1ae040 &amp;lt;+0&amp;gt;: push %r15 0x0000556c1b1ae042 &amp;lt;+2&amp;gt;: lea 0x140fd(%rip),%rax # 0x556c1b1c2146 .</description></item></channel></rss>