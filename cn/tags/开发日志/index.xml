<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>开发日志 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</title><link>/nebula-website/cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</link><description>Recent content in 开发日志 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 14 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="/nebula-website/cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml"/><item><title>基于 Jepsen 来发现几个 Raft 实现中的一致性问题(2)</title><link>/nebula-website/cn/posts/detect-data-consistency-issues-in-raft-implementing-with-jepsen/</link><pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/detect-data-consistency-issues-in-raft-implementing-with-jepsen/</guid><description>Nebula Graph 是一个高性能、高可用、强一致的分布式图数据库。由于 Nebula Graph 采用的是存储计算分离架构，在存储层实际只是暴露了简单的 kv 接口，采用 RocksDB 作为状态机，通过 Raft 一致性协议来保证多副本数据一致的问题。Raft 协议虽然比 Paxos 更加容易理解，但在工程实现上还是有很多需要注意和优化的地方。
另外，如何测试基于 Raft 的分布式系统也是困扰业界的问题，目前 Nebula 主要采用了 Jepsen 作为一致性验证工具。之前我的小伙伴已经在《Jepsen 测试框架在图数据库 Nebula Graph 中的实践》中做了详细的介绍，对 Jepsen 不太了解的同学可以先移步这篇文章。
在这篇文章中将着重介绍如何通过 Jepsen 来对 Nebula Graph 的分布式 kv 进行一致性验证。
强一致的定义 首先，我们需要什么了解叫强一致，它实际就是 Linearizability，也被称为线性一致性。引用《Designing Data-Intensive Applications》里一书里的定义：
In a linearizable system, as soon as one client successfully completes a write, all clients reading from the database must be able to see the value just written.</description></item><item><title>使用 Github Action 进行前端自动化发布</title><link>/nebula-website/cn/posts/github-action-automating-project-process/</link><pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/github-action-automating-project-process/</guid><description>前言 说起自动化，无论是在公司还是我们个人的项目中，都会用到或者编写一些工具来帮助我们去处理琐碎重复的工作，以节约时间提升效率，尤其是我们做前端开发会涉及诸如构建、部署、单元测试等这些开发工作流中重复的事项，本篇文章就是介绍如何利用 GitHub 提供的 Actions 来完成我们前端的发布自动化。
Github Actions 什么是 Actions 笔者个人理解为在某种条件下可被触发的任务，利用一个个任务（Action）就可组建成我们的工作流，想要更详细的介绍定义的同学可以移步 官方Action定义，有助获取更多的信息，这里就不搬运啦~
使用 Actions 的好处 前端自动化部署方案有多种，那么 GitHub 推出的 Actions 有什么魅力呢？在笔者看来，Action 在前端自动化发布有下面 3 点亮点：
免费，Action 可与 GitHub 中的 Repo 进行绑定（下图所示，具体操作见下文），开箱即用：这就意味着我们不需要提供跑任务的机器，也不用管怎么把任务流对接起来，只要简单地熟悉规则，就能将项目 run 起来。而我们大部分觉得某个工具麻烦，是因为使用步骤繁琐，若要实现功能 A，还需做 B/C/D 操作才行，这时候我们要么放弃要么转向操作更简单的工具，毕竟省时省事才是开发第一要务~ 任务插件化，持续丰富的插件开源市场：得益于 Github 定义了 Actions 规范，让我们使用的 Actions 时都是按某种已知规则开发，这使得 Actions 更易于装配复用，很多优秀的开发者在制作完成工作流后，将自己开发的 Actions 放到 GitHub 的 Actions 集市上去，这样尚未完成自己常规工作流的开发，不需要额外开发这些已有重复逻辑直接使用现成的他人 Actions 即可。在笔者的实践过程中，前端的构建部署工作流，就是用的各类现有的 Actions 组合实现的。 和 GitHub 集成好，可避免因为使用 Travis 等第三方工具引起额外的心智负担，在 GitHub 上可直接查看 CI/CD 的情况。 当然 Actions 还有许多其他好处，还待各位亲自尝试，至少使用过 Actions 的人都说好 😬</description></item><item><title>Dev 日志 | 一次 Segmentation Fault 和 GCC Illegal Instruction 编译问题排查</title><link>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</link><pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</guid><description>摘要 笔者最近在重新整理和编译 Nebula Graph 的第三方依赖，选出两个比较有意思的问题给大家分享一下。
Flex Segmentation Fault——Segmentation fault (core dumped) 在编译 Flex 过程中，遇到了 Segmentation fault：
make[2]: Entering directory &amp;#39;/home/dutor/flex-2.6.4/src&amp;#39; ./stage1flex -o stage1scan.c ./scan.l make[2]: *** [Makefile:1696: stage1scan.c] Segmentation fault (core dumped) 使用 gdb 查看 coredump：
Core was generated by `./stage1flex -o stage1scan.c ./scan.l'. Program terminated with signal SIGSEGV, Segmentation fault. #0 flexinit (argc=4, argv=0x7ffd25bea718) at main.c:976 976 action_array[0] = '\0'; (gdb) disas Dump of assembler code for function flexinit: 0x0000556c1b1ae040 &amp;lt;+0&amp;gt;: push %r15 0x0000556c1b1ae042 &amp;lt;+2&amp;gt;: lea 0x140fd(%rip),%rax # 0x556c1b1c2146 .</description></item></channel></rss>