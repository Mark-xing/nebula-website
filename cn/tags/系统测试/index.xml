<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统测试 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</title><link>vesoft-inc.github.io/nebula-website/cn/tags/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/</link><description>Recent content in 系统测试 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 18 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="vesoft-inc.github.io/nebula-website/cn/tags/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>应用 AddressSanitizer 发现程序内存错误</title><link>vesoft-inc.github.io/nebula-website/cn/posts/introduction-to-google-memory-detect-tool-addresssanitizer/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>vesoft-inc.github.io/nebula-website/cn/posts/introduction-to-google-memory-detect-tool-addresssanitizer/</guid><description>作为 C/ C++ 工程师，在开发过程中会遇到各类问题，最常见便是内存使用问题，比如，越界，泄漏。过去常用的工具是 Valgrind，但使用 Valgrind 最大问题是它会极大地降低程序运行的速度，初步估计会降低 10 倍运行速度。而 Google 开发的 AddressSanitizer 这个工具很好地解决了 Valgrind 带来性能损失问题，它非常快，只拖慢程序 2 倍速度。
AddressSanitizer 概述 AddressSanitizer 是一个基于编译器的测试工具，可在运行时检测 C/C++ 代码中的多种内存错误。严格上来说，AddressSanitizer 是一个编译器插件，它分为两个模块，一个是编译器的 instrumentation 模块，一个是用来替换 malloc/free 的动态库。
Instrumentation 主要是针对在 llvm 编译器级别对访问内存的操作（store，load，alloc等），将它们进行处理。动态库主要提供一些运行时的复杂的功能（比如 poison/unpoison shadow memory）以及将 malloc/free 等系统调用函数 hook 住。
AddressSanitizer 基本使用 根据 AddressSanitizer Wiki 可以检测下面这些内存错误
Use after free：访问堆上已经被释放的内存 Heap buffer overflow：堆上缓冲区访问溢出 Stack buffer overflow：栈上缓冲区访问溢出 Global buffer overflow：全局缓冲区访问溢出 Use after return：访问栈上已被释放的内存 Use after scope：栈对象使用超过定义范围 Initialization order bugs：初始化命令错误 Memory leaks：内存泄漏 这里我只简单地介绍下基本的使用，详细的使用文档可以看官方的编译器使用文档，比如 Clang 的文档：https://clang.</description></item><item><title>Jepsen 测试框架在图数据库 Nebula Graph 中的实践</title><link>vesoft-inc.github.io/nebula-website/cn/posts/practice-jepsen-test-framework-in-nebula-graph/</link><pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate><guid>vesoft-inc.github.io/nebula-website/cn/posts/practice-jepsen-test-framework-in-nebula-graph/</guid><description>​在本篇文章中主要介绍图数据库 Nebula Graph 在 Jepsen 这块的实践。
Jepsen 简介 Jepsen 是一款用于系统测试的开源软件库，致力于提高分布式数据库、队列、共识系统等的安全性。作者 Kyle Kingsbury 使用函数式编程语言 Clojure 编写了这款测试框架，并对多个著名的分布式系统和数据库进行了一致性测试。目前 Jepsen 仍在 GitHub 保持活跃，能否通过 Jepsen 的测试已经成为各个分布式数据库对自身检验的一个标杆。
Jepsen 的测试流程 Jepsen 测试推荐使用 Docker 搭建集群。默认情况下由 6 个 container 组成，其中一个是控制节点（control node），另外 5 个是数据库的节点（默认为 n1-n5）。控制节点在测试程序开始后会启用多个 worker 进程，并发地通过 SSH 登入数据库节点进行读写操作。
测试开始后，控制节点会创建一组进程，进程包含了待测试分布式系统的客户端。另一个 Generator 进程产生每个客户端执行的操作，并将操作应用于待测试的分布式系统。每个操作的开始和结束以及操作结果记录在历史记录中。同时，一个特殊进程 Nemesis 将故障引入系统。
测试结束后，Checker 分析历史记录是否正确，是否符合一致性。用户可以使用 Jepsen 的 knossos 中提供的验证模型，也可以自己定义符合需求的模型对测试结果进行验证。同时，还可以在测试中注入错误对集群进行干扰测试。
最后根据本次测试所规定的验证模型对结果进行分析。
如何使用 Jepsen 使用 Jepsen 过程中可能会遇到一些问题，可以参考一下使用 Tips：
在 Jepsen 框架中，用户需要在 DB 接口中对自己的数据库定义下载，安装，启动与终止操作。在终止后，可以将 log 文件清除，同时也可以指定 log 的存储位置，Jepsen 会将其拷贝至 Jepsen 的 log 文件夹中，以便连同 Jepsen 自身的 log 进行分析。 用户还需要提供访问自己数据库的客户端，这个客户端可以是你用 Clojure 实现的，比如 etcd 的verschlimmbesserung，也可以是 JDBC，等等。然后需要定义 Client 接口，告诉 Jepsen 如何对你的数据库进行操作。 在 Checker 中，你可以选择需要的测试模型，比如，性能测试（checker/perf）将会生成 latency 和整个测试过程的图表，时间轴（timeline/html）会生成一个记录着所有操作时间轴的 html 页面。 另外一个不可或缺的组件就是在 nemesis 中注入想要测试的错误了。网络分区（nemesis/partition-random-halves）和杀掉数据节点（kill-node）是比较常见的注入错误。 在 Generator 中，用户可以告知 worker 进程需要生成哪些操作，每一次操作的时间间隔，每一次错误注入的时间间隔等等。 用 Jepsen 测试图数据库 Nebula Graph 分布式图数据库 Nebula Graph 主要由 3 部分组成，分别是 meta 层，graph 层和 storage 层。</description></item></channel></rss>