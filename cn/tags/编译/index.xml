<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</title><link>/nebula-website/cn/tags/%E7%BC%96%E8%AF%91/</link><description>Recent content in 编译 on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 20 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="/nebula-website/cn/tags/%E7%BC%96%E8%AF%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Dev 日志 | 一次 Segmentation Fault 和 GCC Illegal Instruction 编译问题排查</title><link>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</link><pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/segmentation-fault-gcc-illegal-instruction-trouble-shooting/</guid><description>摘要 笔者最近在重新整理和编译 Nebula Graph 的第三方依赖，选出两个比较有意思的问题给大家分享一下。
Flex Segmentation Fault——Segmentation fault (core dumped) 在编译 Flex 过程中，遇到了 Segmentation fault：
make[2]: Entering directory &amp;#39;/home/dutor/flex-2.6.4/src&amp;#39; ./stage1flex -o stage1scan.c ./scan.l make[2]: *** [Makefile:1696: stage1scan.c] Segmentation fault (core dumped) 使用 gdb 查看 coredump：
Core was generated by `./stage1flex -o stage1scan.c ./scan.l'. Program terminated with signal SIGSEGV, Segmentation fault. #0 flexinit (argc=4, argv=0x7ffd25bea718) at main.c:976 976 action_array[0] = '\0'; (gdb) disas Dump of assembler code for function flexinit: 0x0000556c1b1ae040 &amp;lt;+0&amp;gt;: push %r15 0x0000556c1b1ae042 &amp;lt;+2&amp;gt;: lea 0x140fd(%rip),%rax # 0x556c1b1c2146 .</description></item><item><title>使用 Docker 构建 Nebula Graph 源码</title><link>/nebula-website/cn/posts/build-nebula-graph-source-code-with-docker/</link><pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/build-nebula-graph-source-code-with-docker/</guid><description>Nebula Graph 介绍 Nebula Graph 是开源的高性能分布式图数据库。项目使用 C++ 语言开发，cmake 工具构建。其中两个重要的依赖是 Facebook 的 Thrift RPC 框架和 folly 库.
由于项目采用了 C++ 14 标准开发，需要使用较新版本的编译器和一些三方库。虽然 Nebula Graph 官方给出了一份开发者构建指南，但是在本地构建完整的编译环境依然不是一件轻松的事。
开发环境构建 Nebula Graph 依赖较多，且一些第三方库需本地编译安装，为了方便开发者本地编译项目源码， Nebula Graph 官方为大家提供了一个预安装所有依赖的 [docker 镜像](docker hub)。开发者只需如下的三步即可快速的编译 Nebula Graph 工程，参与 Nebula Graph 的开源贡献：
本地安装好 Docker
将 vesoft/nebula-dev 镜像 pull 到本地
$ docker pull vesoft/nebula-dev 运行 Docker 并挂载 Nebula 源码目录到容器的 /home/nebula 目录 $ docker run --rm -ti -v {nebula-root-path}:/home/nebula vesoft/nebula-dev bash 感谢社区伙伴 @阿东 提的建议，把上面的 {nebula-root-path} 替换成你 Nebula Graph 实际 clone 的目录</description></item><item><title>图数据库 Nebula Graph 的安装部署</title><link>/nebula-website/cn/posts/nebula-graph-database-deployment/</link><pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate><guid>/nebula-website/cn/posts/nebula-graph-database-deployment/</guid><description>Nebula Graph：一个开源的分布式图数据库。作为唯一能够存储万亿个带属性的节点和边的在线图数据库，Nebula Graph 不仅能够在高并发场景下满足毫秒级的低时延查询要求，还能够实现服务高可用且保障数据安全性。
本文目录 简介 Nebula 整体架构 Meta Service Storage Service Graph Service 安装部署 单机运行 集群部署 环境准备 安装 配置 测试集群 简介 Nebula Graph 是开源的第三代分布式图数据库，不仅能够存储万亿个带属性的节点和边，而且还能在高并发场景下满足毫秒级的低时延查询要求。不同于 Gremlin 和 Cypher，Nebula 提供了一种 SQL-LIKE 的查询语言 nGQL，通过三种组合方式（管道、分号和变量）完成对图的 CRUD 的操作。在存储层 Nebula Graph 目前支持 RocksDB 和 HBase 两种方式。
感谢 Nebula Graph 社区 Committer 伊兴路供稿本文。
Nebula Graph 整体架构 Nebula Graph 主要有三个服务进程：
Meta Service Meta Service 是整个集群的元数据管理中心，采用 Raft 协议保证高可用。主要提供两个功能:</description></item></channel></rss>