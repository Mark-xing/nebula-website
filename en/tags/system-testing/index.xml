<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System-Testing on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</title><link>https://nebula-graph.io/en/tags/system-testing/</link><description>Recent content in System-Testing on Nebula Graph - An Open Source, Distributed and High Performant Graph Database</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 18 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nebula-graph.io/en/tags/system-testing/index.xml" rel="self" type="application/rss+xml"/><item><title>An Introduction to Google's Memory Error Detect Tool AddessSanitizer</title><link>https://nebula-graph.io/en/posts/introduction-to-google-memory-detect-tool-addresssanitizer/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://nebula-graph.io/en/posts/introduction-to-google-memory-detect-tool-addresssanitizer/</guid><description>As a C/C++ developer, you will encounter various problems during development, the most common ones are memory usage issues such as out of bounds, leakage.
Previously the most commonly used memory error detect tool was Valgrind, but the biggest problem with Valgrind is that it will greatly reduce program speed, by 10 times by estimate.
Good news is the Google-developed memory error detect tool, AddressSanitizer (aka ASan), has greatly improved the program slowdown to two times only on average, which is very fast.</description></item><item><title>Practice Jepsen Test Framework in Nebula Graph</title><link>https://nebula-graph.io/en/posts/practice-jepsen-test-framework-in-nebula-graph/</link><pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate><guid>https://nebula-graph.io/en/posts/practice-jepsen-test-framework-in-nebula-graph/</guid><description>​This article introduces how Nebula Graph uses Jepsen test framework to ensure system linearizability.
Why Jepsen? Linearizability here specifically means consistency in the CAP theory. In Nebula Graph, we gurantee strong data consistency in our key-value store.
So under such a consistency policy, we need to make sure:
A read happens BEFORE a write operation ends must read the previous write A read happens AFTER a write operation ends must read the current write Strong data consistency relies on a solid chaos testing plan which can affect a distributed system in many unplanned ways, which in turn helps uncover corner cases that are hard to detect in development.</description></item></channel></rss>